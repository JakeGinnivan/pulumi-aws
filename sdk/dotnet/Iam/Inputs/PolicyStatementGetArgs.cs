// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Aws.Iam.Inputs
{

    /// <summary>
    /// The Statement element is the main element for a policy. This element is required. It can include multiple elements
    /// (see the subsequent sections in this page). The Statement element contains an array of individual statements.
    /// </summary>
    public sealed class PolicyStatementGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Include a list of actions that the policy allows or denies.
        /// </summary>
        [Input("Action")]
        public InputUnion<string, ImmutableArray<string>>? Action { get; set; }

        [Input("Condition")]
        private InputMap<ImmutableDictionary<string, Union<string, ImmutableArray<string>>>>? _Condition;

        /// <summary>
        /// Specify the circumstances under which the policy grants permission.
        /// 
        /// The Condition element (or Condition block) lets you specify conditions for when a policy is in effect. The Condition
        /// element is optional. In the Condition element, you build expressions in which you use condition operators (equal,
        /// less than, etc.) to match the condition in the policy against values in the request. Condition values can include
        /// date, time, the IP address of the requester, the ARN of the request source, the user name, user ID, and the user
        /// agent of the requester. Some services let you specify additional values in conditions; for example, Amazon S3
        /// lets you write a condition using the s3:VersionId key, which is unique to that service.
        /// 
        /// This block maps condition operators to their arguments. Condition operators are the "verbs" of conditions and specify
        /// the type of comparison that IAM performs. The condition operators are grouped into the following categorties:
        /// 
        ///     - String
        ///     - Numeric
        ///     - Date and time
        ///     - Boolean
        ///     - Binary
        ///     - IP address
        ///     - Amazon Resource (ARN) (available for some services)
        ///     - ...IfExists (checks if the key value exists as part of another check)
        ///     - Null check (checks if the key value exists as a standalone check)
        /// 
        /// For details on all of the available operators and their arguments, please refer to the AWS documentation:
        /// https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition_operators.html.
        /// 
        /// Examples of arguments are:
        ///  - { "aws:MultiFactorAuthPresent": "true" }
        ///  - { "aws:SourceIp": [ "203.0.113.0/24", "2001:DB8:1234:5678::/64" ]}
        /// </summary>
        public InputMap<ImmutableDictionary<string, Union<string, ImmutableArray<string>>>> Condition
        {
            get => _Condition ?? (_Condition = new InputMap<ImmutableDictionary<string, Union<string, ImmutableArray<string>>>>());
            set => _Condition = value;
        }

        /// <summary>
        /// Indicate whether the policy allows or denies access.
        /// </summary>
        [Input("Effect", required: true)]
        public Input<string> Effect { get; set; } = null!;

        /// <summary>
        /// Include a list of actions that are not covered by this policy.
        /// </summary>
        [Input("NotAction")]
        public InputUnion<string, ImmutableArray<string>>? NotAction { get; set; }

        /// <summary>
        /// Indicate the account, user, role, or federated user to which this policy does not apply.
        /// </summary>
        [Input("NotPrincipal")]
        public InputUnion<string, InputUnion<Inputs.AWSPrincipalGetArgs, InputUnion<Inputs.ServicePrincipalGetArgs, Inputs.FederatedPrincipalGetArgs>>>? NotPrincipal { get; set; }

        /// <summary>
        /// A list of resources that are specifically excluded by this policy.
        /// </summary>
        [Input("NotResource")]
        public InputUnion<string, ImmutableArray<string>>? NotResource { get; set; }

        /// <summary>
        /// Indicate the account, user, role, or federated user to which you would like to allow or deny access. If you are
        /// creating a policy to attach to a user or role, you cannot include this element. The principal is implied as that
        /// user or role.
        /// 
        /// Use the Principal element to specify the user (IAM user, federated user, or assumed-role user), AWS account, AWS
        /// service, or other principal entity that is allowed or denied access to a resource. You use the Principal element in
        /// the trust policies for IAM roles and in resource-based policiesâ€”that is, in policies that you embed directly in a
        /// resource. For example, you can embed such policies in an Amazon S3 bucket, an Amazon Glacier vault, an Amazon SNS
        /// topic, an Amazon SQS queue, or an AWS KMS customer master key (CMK).
        /// 
        /// Use the Principal element in these ways:
        /// 
        ///     - In IAM roles, use the Principal element in the role's trust policy to specify who can assume the role. For
        ///       cross-account access, you must specify the 12-digit identifier of the trusted account.
        /// 
        ///       Note: After you create the role, you can change the account to "*" to allow everyone to assume the role. If
        ///       you do this, we strongly recommend that you limit who can access the role through other means, such as a
        ///       Condition element that limits access to only certain IP addresses. Do not leave your role accessible to
        ///       everyone!
        /// 
        ///     - In resource-based policies, use the Principal element to specify the accounts or users who are allowed to
        ///       access the resource.
        /// 
        /// Do not use the Principal element in policies that you attach to IAM users and groups. Similarly, you do not specify
        /// a principal in the permission policy for an IAM role. In those cases, the principal is implicitly the user that the
        /// policy is attached to (for IAM users) or the user who assumes the role (for role access policies). When the policy
        /// is attached to an IAM group, the principal is the IAM user in that group who is making the request.
        /// </summary>
        [Input("Principal")]
        public InputUnion<string, InputUnion<Inputs.AWSPrincipalGetArgs, InputUnion<Inputs.ServicePrincipalGetArgs, Inputs.FederatedPrincipalGetArgs>>>? Principal { get; set; }

        /// <summary>
        /// A list of resources to which the actions apply.
        /// </summary>
        [Input("Resource")]
        public InputUnion<string, ImmutableArray<string>>? Resource { get; set; }

        /// <summary>
        /// An optional statement ID to differentiate between your statements.
        /// </summary>
        [Input("Sid")]
        public Input<string>? Sid { get; set; }

        public PolicyStatementGetArgs()
        {
        }
    }
}
